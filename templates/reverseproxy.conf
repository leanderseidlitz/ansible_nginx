################################################################################
# This file was generated by Ansible for {{ inventory_hostname }}
# Do NOT modify this file by hand!
################################################################################

### UPSTREAMS
{% for upstream in item.location_to_upstream %}
{% if upstream.protocol is defined %}
upstream {{ (upstream.location + '_' + item.fqdn_) |regex_replace("[^0-9a-zA-Z_]+", "") }}_backend {
{% if upstream.addrs is defined %}
{% for u in upstream.addrs %}
    server {{ u }};
{% endfor %}
{% elif upstream.socket_path is defined %}
   server unix:{{ upstream.socket_path }};
{% endif %}
}
{% endif %}
{% endfor %}
{% if (item.ssl_client_auth.enabled |default(false)) and (item.ssl_client_auth.force_cn is defined) %}

## USED FOR TLS CLIENT AUTH
map $ssl_client_s_dn $proxy_certificate {
    default 0;
    CN={{ item.ssl_client_auth.force_cn }} 1;
}
{% endif %}

{% if (item.letsencrypt.enabled |default(false)) or (item.ssl.enabled |default(false)) %}
### HTTP REDIRECT (ONLY IF SSL/LETSENCRYPT ENABLED)
server {
{% if (item.listen.ipv4 is defined and item.listen.ipv4) or item.listen.ipv4 is not defined %}
    listen
    {{- ' ' + (item.listen.ipv4 |default('')) -}}
    {{- ':' if item.listen.ipv4 is defined else '' -}}
    {{- item.port.http |default(80) }};
{% endif %}
{% if (item.listen.ipv6 is defined and item.listen.ipv6) or item.listen.ipv6 is not defined %}
    listen
    {{- ' ' + (item.listen.ipv6 |default('[::]')) + ':' -}}
    {{- item.port.http |default(80) }};
{% endif %}

    server_name {{ item.fqdn_ |regex_replace("_+$", "") }}{{ ([''] + (item.additional_domains | default([]))) | join(' ') }};
    server_tokens off;
    location / {
       return 301 https://$host$request_uri;
    }

{% if item.letsencrypt.enabled |default(false) %}
    location /.well-known/acme-challenge {
        alias /var/www/{{ item.fqdn_ }}/.well-known/acme-challenge;
    }
{% endif %}

    ## LOGGING
{% if item.log.syslog| default(false) %}
    access_log syslog:server=unix:/dev/log,facility=local0,severity=info,nohostname {{ item.log.access_fmt |default('combined') }};
    error_log syslog:server=unix:/dev/log,facility=local0,severity=error,nohostname {{ item.log.error_fmt |default('error') }};
{% else %}
    access_log /var/log/nginx/{{ item.fqdn_ }}_access.log {{ item.log.access_fmt |default('combined') }};
    error_log /var/log/nginx/{{ item.fqdn_ }}_error.log {{ item.log.error_fmt |default('error') }};
{% endif %}
}
{% endif %}

### MAIN SERVER (SSL / HTTP)
server {
{% if (item.listen.ipv4 is defined and item.listen.ipv4) or item.listen.ipv4 is not defined %}
    listen
    {{- ' ' + (item.listen.ipv4 |default('')) -}}
    {{- ':' if item.listen.ipv4 is defined else '' -}}
{%-   if (item.letsencrypt.enabled |default(false)) or (item.ssl.enabled |default(false)) -%}
    {{- item.port.https |default(443) }} ssl;
{%   else %}
    {{- item.port.http |default(80) }};
{%   endif %}
{% endif %}
{% if (item.listen.ipv6 is defined and item.listen.ipv6) or item.listen.ipv6 is not defined %}
    listen
    {{- ' ' + (item.listen.ipv6 |default('[::]')) + ':' -}}
{%-   if (item.letsencrypt.enabled |default(false)) or (item.ssl.enabled |default(false)) -%}
    {{- item.port.https |default(443) }} ssl;
{%   else %}
    {{- item.port.http |default(80) }};
{%   endif %}
{% endif %}

    server_name {{ item.fqdn_ |regex_replace("_+$", "") }}{{ ([''] + (item.additional_domains | default([]))) | join(' ') }};
    server_tokens off;

{% if (item.redirect_to_primary |default(false)) and item.additional_domains is defined %}
    ## redirect to primary domain
    if ($host != '{{ item.fqdn_ |regex_replace("_+$", "") }}') {
        return 301 https://{{ item.fqdn_ |regex_replace("_+$", "") }}$request_uri;
    }
{% endif %}
{% if item.hsts is defined %}
    ## HSTS
    add_header Strict-Transport-Security "max-age={{ item.hsts.max_age }}; {% if item.hsts.includeSubDomains %}includeSubDomains; preload{% endif %}" always;
{% endif %}
    ## LOGGING
{% if item.log.syslog| default(false) %}
    access_log syslog:server=unix:/dev/log,facility=local0,severity=info,nohostname {{ item.log.access_fmt |default('combined') }};
    error_log syslog:server=unix:/dev/log,facility=local0,severity=error,nohostname {{ item.log.error_fmt |default('error') }};
{% else %}
    access_log /var/log/nginx/{{ item.fqdn_ }}_access.log {{ item.log.access_fmt |default('combined') }};
    error_log /var/log/nginx/{{ item.fqdn_ }}_error.log {{ item.log.error_fmt |default('error') }};
{% endif %}

{% if (item.letsencrypt.enabled |default(false)) and not (item.ssl.enabled |default(false)) %}
    ## SSL
    ssl_certificate /etc/letsencrypt/live/{{ item.fqdn_ }}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{ item.fqdn_ }}/privkey.pem;
{% elif (item.ssl.enabled |default(false)) and not (item.letsencrypt.enabled |default(false)) %}
    ssl_certificate {{ item.ssl.pem_path }};
    ssl_certificate_key {{ item.ssl.key_path }};
{% endif %}
{% if (item.letsencrypt.enabled |default(false)) or (item.ssl.enabled |default(false)) %}
    ssl_session_timeout 5m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
{% endif %}
{% if item.ssl_client_auth.enabled |default(false) %}
    ## TLS CLIENT AUTH
    ssl_client_certificate {{ item.ssl_client_auth.ca_cert }};
    ssl_verify_client on;
{% endif %}

{% if item.letsencrypt is defined %}
    location /.well-known/acme-challenge {
        alias /var/www/{{ item.fqdn_ }}/.well-known/acme-challenge;
    }
{% endif %}
{% if item.error_pages is defined  %}
{% for error_page in item.error_pages %}
    error_page {{ error_page.codes | join(' ') }} {{error_page.site}};
    location = {{error_page.site}} {
        root {{ error_page.location }};
        internal;
    }
{% endfor %}
{% endif %}

{% for upstream in item.location_to_upstream %}
    location {{ upstream.location }}{{ '/' if upstream.location[-1] != '/' and not (upstream.no_trail_slash |default(false)) else '' }} {
{% if (item.ssl_client_auth.enabled |default(false)) and (item.ssl_client_auth.force_cn is defined) %}
        # FORCE CLIENT TLS AUTH CN
        if ( $proxy_certificate != 1 ) {
            return 403;
        }
{% endif %}
        gzip off;
        client_max_body_size {{ upstream.client_max_body_size | default('50M') }};
{% if upstream.webroot is defined %}
        root {{ upstream.webroot }};
{% elif upstream.alias is defined %}
   	alias {{ upstream.alias }};
{% else %}
{%    if (item.letsencrypt is defined) or (item.ssl.enabled is defined) %}
        proxy_set_header X-Forwarded-Ssl on;
{%    endif %}
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Frame-Options SAMEORIGIN;
{%     if upstream.protocol == 'https' and item.tls_to_upstream.client_auth |default(false) %}
        proxy_ssl_certificate         {{ item.tls_to_upstream.cert }};
        proxy_ssl_certificate_key     {{ item.tls_to_upstream.key }};
{%     endif %}
{%     if upstream.protocol == 'https' and item.tls_to_upstream.cacert is defined %}
        proxy_ssl_verify              on;
        proxy_ssl_verify_depth        3;
        proxy_ssl_session_reuse       on;
        proxy_ssl_name                {{ item.fqdn_ |regex_replace("_+$", "") }};
        proxy_ssl_trusted_certificate {{ item.tls_to_upstream.cacert }};
{%     endif %}

{%    if upstream.protocol == 'uwsgi' %}
        uwsgi_pass {{ (upstream.location + '_' + item.fqdn_) |regex_replace("[^0-9a-zA-Z_]+", "") }}_backend;
        include {{ uwsgi_param_location |default('/etc/nginx/uwsgi_params') }};
{%    elif upstream.protocol is defined %}
        proxy_pass {{ upstream.protocol }}://{{ (upstream.location + '_' + item.fqdn_) |regex_replace("[^0-9a-zA-Z_]+", "") }}_backend{{ upstream.upstream_location| default('') }}{{ "/" if upstream.pass_normalized_uri |default(false) }};
{%     endif %}
{% endif %}
{% for option in upstream.additional_options |default([]) %}
        {{ option }};
{% endfor %}
{% if item.basic_auth is defined %}
        auth_basic "{{ item.basic_auth.message |default('Restricted Content') }}";
        auth_basic_user_file /etc/nginx/{{ item.fqdn_ }}_htpasswd;
{% endif %}
    }
{% endfor %}
}
